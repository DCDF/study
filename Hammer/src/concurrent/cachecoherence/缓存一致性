缓存一致性问题原因
-计算机模型
CPU - 高速缓存  
CPU - 高速缓存 - 一致性协议 - 主内存
CPU - 高速缓存   
高速缓存引入原因
运算速度和处理器差不多,CPU指令速度远大于内存设备读写速度,运算数据复制到缓存,处理完毕同步到内存

-Java内存模型(JMM)
线程 - 工作内存
线程 - 工作内存 - 操作 - 内存
线程 - 工作内存
所有共享变量(实例和类变量,局部变量为线程私有)存储在主内存中
工作内存中保留被操作的变量的工作副本
不能访问其他线程的工作内存,只有通过内存中转(CacheCoherence中设置flag无效原因)
线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁(CacheCoherenceSynchronized成功原因)

Volatile做了啥
保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制
线程操作数据时是通过直接从主内存读取到工作内存,操作结束写回时使其他线程读取的变量副本失效
Intel的MESI（缓存一致性协议）
CPU写数据时,如为共享变量,通知其他CPU将该变量缓存行设置无效,当读取无效时会从内存读取
CPU会嗅探总线中传输数据来检查自己缓存值是否过期,过期操作时会从内存读取,也是不建议大量使用Volatile原因
禁止指令重排序可以解决单例双重检查对象初始化代码执行乱序问题(编译器,处理器,内存系统的优化)
适用于属性被多个线程共享,其中有一个线程修改了此属性,其他线程可以立即得到修改后的值,比如booleanflag;或者作为触发器,实现轻量级同步
volatile属性的读写操作无锁，所以低成本的
volatile属性不会被线程缓存,始终从内存读取
happens-before保证,对volatile变量v的写入happens-before所有其他线程后续对v的读操作。
可以使得long和double的赋值是原子的 (?)
可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性
