java内存模型(JMM)
线程栈:每个线程一个,存储原始类型的本地变量,对象引用,对象成员变量引用,方法内变量等,不共享
堆:所有对象都存在堆中
线程访问堆中对象的变量都会在本地有一份私有拷贝

竞态条件:线程1读取共享变量数据到CPU1缓存中执行+1,这时线程2也做和1同样的事,无论1还是2线程写回主存都是只+1

同步块
1:同一时间只有一个线程进入临界区,并且保证所有变量都是直接从内存读取,退出同步块时写回内存
2:Java中同步块都是同步在对象上
3:一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行
4:JVM每个类只有一个类对象,所以同步静态方法和同步实例方法不是同步的

Volatile
保证变量都是通过内存直接获取,读写无锁,保证单一线程写的情况下是安全的

死锁
1:多个线程同时但以不同的顺序请求同一组锁的时候 > 线程1锁A然后准备锁B,线程2锁B然后准备锁A,互相等待锁
> 加锁顺序,只要保证同一组锁已相同顺序去锁就行,给需要加锁的对象按照固定顺序排序

阿姆达尔定律
T=串行总时间,B=不可并行时间,T-B=并行总时间
T = B + (T – B)
线程或者CPU的个数我们记为N,可并行化部分被执行的最快时间可以通过下面的公式计算出来：
(T – B ) / N
当一个线程可并行部分使用N个CPU或者线程时
T(N) = B + ( T – B ) / N
T(N) = B + (T(1) – B) / N
优化不可并行部分因子O
T(O, N) = B / O + (1 - B / O) / N

线程数量计算
Runtime.getRuntime().availableProcessors();获取处理器核心数
线程数=核心数/(1-阻塞系数),计算密集型任务阻塞系数为0,IO密集型任务阻塞系统无限接近1

wait/notify
1:一个线程调用任意一个对象的wait方法就会进入等待状态,直到别的线程调用同一个对象的notify方法(1:定向唤醒思路,每个线程调用不同对象wait 2:会引发假唤醒)
2:JVM/编译器内部会把字符串常量装换成同一个对象(会引发假唤醒)
3:调用wait()时线程会释放掉该对象上的锁(锁A,锁B,调用B的wait()只会放掉B的锁,线程会持有A的锁进入等待)
4:JVM强制wait和notify必须在同步块中,所以线程被唤醒退出wait()时需要等待notify同步块执行完毕并释放锁
5:notify一次唤醒一个线程(会引发假唤醒),notifyall唤醒该对象上所有等待的线程

重入
一个线程拥有一个监视器对象锁后就可以访问该监视器对象同步的所有代码块,这就是可重入

Lock
1:不可重入,调用lock()时状态改变,其他线程进入会自旋锁,while(isLock)wait();isLock=true;

读写锁
读请求:正在写>写请求>读请求
写请求:同时只能一个线程,需考虑写重入



读重入锁 正在写>读重入>写请求
写重入锁 正在读>无正在写>正在写的线程重入 -> 仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）
读锁升级写锁 拥有读锁且是唯一读>正在读>无写锁>>-> 这个线程是唯一一个拥有读锁的线程
写锁降级到读锁 有读锁自然其他线程不可能有读锁写锁

